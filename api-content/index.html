{"posts":[{"title":"LeetCode刷题记录","content":" 记录LeetCode做的题 ","link":"https://eric-tom.github.io/post/leetcode-shua-ti-ji-lu/"},{"title":"算法与数据结构（C++）","content":" 此部分非常非常重要，同时特特特难，从今天开始j记录相关知识！加油！ 如何选择编程语言和编译器？ 其实都可以，看个人爱好，我个人首次接触的编程语言是C++，所以常用便习惯了。 很多考试都会限定程序的运行时间的上限,因此选择尽可能快的编程语言是非常重要的。一般来说，可供选择的语言有C、C++、Java等，但是Java的执行比较慢，因此较常使用的是C或C++。考虑到C++的语法向下兼容C，并且C的输入输出语句比C++的要快很多，因此我们可以在主体上使用C语言的语法;而C++中有一些特性和功能非常好用（例如变量可以随时定义、拥有标准模板库STL等)，因此在一定程度上我们可以混用部分C++的语法(事实上，由于C++向下兼容C，因此一般都是在C++中写C语言的语法)。 编译器的选择则因人而异、因现场环境而异。不同的考试可能提供不同的编译器，要根据具体情况来选择。但一般来说，可能出现的编译器有VC 6.0、VS系列、Dev-C++、C-Free.Code:Blocks、Eclipse、Idea等，其中VC 6.0因为标准过于古老，很多语法在其中没办法通过编译，所以尽量不要使用;Dev-C++、C-Free、Code::Blocks则是轻便好用的编译器，推荐使用，可以根据具体情况来选择;VS系列是较为厚重的编译器，在没有其他轻便编译器可供选择的情况下使用;Eclipse、Idea则更常用于Java代码的编写。 第一节 时间复杂度和空间复杂度 一、算法的时间复杂度定义 在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度。记作：T(n)=O(f(n))。它表示随问题n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中，f(n)是问题规模n的某个函数。 这样用大写O()来体现算法时间复杂度的记法，我们称之为大0记法。 二、推导大O阶方法 用常数1取代运行时间中的所有加法常数。 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。 三、推导示例 常数阶 首先顺序结构的时间复杂度。下面这个算法，是利用高斯定理计算1，2，……n个数的和。 int sum = 0, n = 100; /执行一次/ sum = (1 + n) * n / 2; /执行一次/ printf(&quot;%d&quot;,sum); /执行一次/ 这个算法的运行次数函数是f (n) =3。 根据我们推导大0阶的方法，第一步就是把常数项3 改为1。在保留最高阶项时发现，它根本没有最高阶项，所以这个算法的时间复杂度为0(1)。 另外，我们试想一下，如果这个算法当中的语句 sum = (1+n)*n/2; 有10 句，则与示例给出的代码就是3次和12次的差异。这种与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O(1)的时间复杂度，又叫常数阶。对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着n 的变大而发生变化，所以单纯的分支结构(不包含在循环结构中)，其时间复杂度也是0(1)。 四、常见的时问复杂度如表所示。 常用的时间复杂度所耗费的时间从小到大依次是： O(1)&lt; O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n2)&lt;O(n3)&lt;O(2n)&lt;O(n!)&lt;O(nn) 五、最坏情况与平均情况 我们查找一个有n 个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为O(1)，但也有可能这个数字就在最后一个位置上待着，那么算法的时间复杂度就是O(n)，这是最坏的一种情况了。 最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。 在应用中，这是一种最重要的需求， 通常， 除非特别指定， 我们提到的运行时间都是最坏情况的运行时间。 而平均运行时间也就是从概率的角度看， 这个数字在每一个位置的可能性是相同的，所以平均的查找时间为n/2次后发现这个目标元素。平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。也就是说，我们运行一段程序代码时，是希望看到平均运行时间的。可现实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。一般在没有特殊说明的情况下，都是指最坏时间复杂度。 六、算法空间复杂度 我们在写代码时，完全可以用空间来换取时间，比如说，要判断某某年是不是闰年，你可能会花一点心思写了一个算法，而且由于是一个算法，也就意味着，每次给一个年份，都是要通过计算得到是否是闰年的结果。 还有另一个办法就是，事先建立一个有2050个元素的数组(年数略比现实多一点)，然后把所有的年份按下标的数字对应，如果是闰年，此数组项的值就是1，如果不是值为0。这样，所谓的判断某一年是否是闰年，就变成了查找这个数组的某一项的值是多少的问题。此时，我们的运算是最小化了，但是硬盘上或者内存中需要存储这2050个0和1。这是通过一笔空间上的开销来换取计算时间的小技巧。到底哪一个好，其实要看你用在什么地方。 算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作:S(n)= O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。 一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元，若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为0(1)。 通常， 我们都使用&quot;时间复杂度&quot;来指运行时间的需求，使用&quot;空间复杂度&quot;指空间需求。当不用限定词地使用&quot;复杂度'时，通常都是指时间复杂度。 七、一些计算的规则 加法规则 T(n,m) = T1(n) + T2(m) = O(max{f(n), g(m)}) 乘法规则 T(n,m) = T1(n) * T2(m) = O(max{f(n)*g(m)}) 一个经验 复杂度与时间效率的关系： c(常数) &lt; logn &lt; n &lt; n*logn &lt; n^2 &lt; n^3 &lt; 2^n &lt; 3^n &lt; n! |----------------------------|-----------------------|-------------| |----------- 较好----------|--------一般 --------|----较差----| 八、常用算法的时间复杂度和空间复杂度 OJ上的题目一般都有对运行时间和空间的说明，例如： Time Limit:2000/1000ms(Java/Others) Memory Limit:65536/65536KB(Java/Others) #include &lt;bits/stdc+t.h&gt; using namespace std; int main( ) { int i,k,n = 1e8; clock_t start,end; start = clock( ); for(i = 0; i&lt;n; i++)k++; //循环次数 end = clock( ) ; cout &lt;&lt;( double)( end - start) / CLOCKS_PER_SEC&lt;&lt;endl; } 上面的程序在一台普通配置的计算机运行，例如CPU为i5-8250U、内存为8GB、64位的操作系统，结果如下： 当n=1e8=10时,输出的运行时间是0.164s。 当n=le9时,输出的运行时间是1.645s。 评测用的OJ服务器,性能可能比这个好一些,也可能差不多。 所以,如果题目要求“Time Limit : 2000/1000ms(Java/Others)”,那么内部的循环次数应该满足n≤108,即1亿次以内。 由于程序的运行时间依赖于计算机的性能,不同的计算机结果不同,所以直接把运行时间作为判断标准并不准确。通常,用程序执行的“次数”来衡量更加合理,例如上述程序循环了n次,把它的运行效率记为O(n)。 九、避免算法竞赛超时小技巧 判断奇偶数的时候，使用’&amp;'更高效 在判断一个数的奇数还是偶数的时候，很多小伙伴会使用%来求一个数除以2的余数来进行判断，其实这里我们有更高效的方法，那就是&amp;与运算，如果a&amp;1 == 1则a为奇数，a&amp;1 == 0则a为偶数。 能转换为迭代的函数，尽量不要写递归 算法最高不要超过O(n^2) 在我们正常的算法竞赛中，当你写出来一个时间复杂度比O(n2)的算法时，那你这题基本是凉透了，或者说你只想拿前两个样例(如果是按测试点的比赛，如果实在想不出来，最后可以写个完全暴力，能骗几分是几分)。一般来说，时间效率到O(n 2)一般都很高了，已经很难过全部样例了，如果是压轴题的话，O(n)算法都比较难过全部样例，得需要优化到O(lgn)才保险。 学会以空间换时间 在算法竞赛中，我们一般会经常超出时间限制，但是超出空间限制的还是很少的，一般比赛给的都是16MB甚至256MB，根本用不完啊，而且多开几个数组也完全的占不了几个字节，但是这能让我们的程序节省上百倍的时间。这里就拿昨天写的一题来举例吧：LeetCode 每日一题 42. 接雨水,原文有具体的题目和代码，这里为了方便，我们把两段代码分别拿过来。 ","link":"https://eric-tom.github.io/post/suan-fa-yu-shu-ju-jie-gou-c/"},{"title":"Markdown基本语法","content":" Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 优点： 1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。 2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可 缺点： 1、需要记一些语法（当然，是很简单。五分钟学会）。 2、有些平台不支持Markdown编辑模式。 以下仅展示部分功能，例如 [TOC] 自动生成目录无法显示，更好的体验去Markdown编辑器去写，资料摘取网上，方便自己学习。 一、标题 一个#是一级标题，二个#是二级标题，以此类推。最大支持六级标题。（❗️ #后跟个空格再写文字） 示例： 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 二、字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 例子： 这是加粗的文字 这是倾斜的文字` 这是斜体加粗的文字 这是加删除线的文字 三、引用 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;甚至n个 例子： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线 三个或者三个以上的-或者* 都可以。 示例： 五、图片 网络（可以将上传到图床、七牛云等） 语法： !+[图片alt](图片地址 ''图片title'') 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 例子： 本地 直接导入。 六、超链接 语法： 超链接名 title可加可不加 例子： 百度 He: 1101576016@qq.com 七、列表（❗️ 符号后跟个空格再写文字） 无序列表 语法： 用 - + * 其中一种 例子： 列表内容 列表内容 列表内容 有序列表 语法： 数字加点 例子： 列表内容 列表内容 列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 八、表格 语法： Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 表头 表头 单元格 单元格 单元格 单元格 第二行为内容格式。 文字默认居左 -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 例子： 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 九、代码 语法： 单行代码：代码之间分别用一个反引号包起来 代码块：用 ``` 包裹一段代码，并指定一种语言（也可以不指定） 示例： 单行代码 printf() 函数 代码块 $(document).ready(function () { alert('RUNOOB'); }); //C++示例 include&lt;iostream&gt; using namespace std; int main() { cout&lt;&lt;&quot;Hello World!&quot;&lt;&lt;endl; return 0; } 十、标准流程图 st=&gt;start: 开始框 op=&gt;operation: 处理框 cond=&gt;condition: 判断框(是或否?) sub1=&gt;subroutine: 子流程 io=&gt;inputoutput: 输入输出框 e=&gt;end: 结束框 st-&gt;op-&gt;cond cond(yes)-&gt;io-&gt;e cond(no)-&gt;sub1(right)-&gt;op 十一、UML时序图（❗️ 真实用时请去掉头尾行） 对象A-&gt;对象B: 对象B你好吗?（请求） Note right of 对象B: 对象B的描述 Note left of 对象A: 对象A的描述(提示) 对象B--&gt;对象A: 我很好(响应) 对象A-&gt;对象B: 你真的好吗？ 十二、甘特图样例（❗️ 真实用时请去掉头尾行） %% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h ","link":"https://eric-tom.github.io/post/shu-ju-jie-gou-yu-suan-fa-c/"},{"title":"数据库重要知识","content":"一、left join,right join,inner join,full join之间的区别 1.inner join（内连接），在两张表进行连接查询时，只保留两张表中完全匹配的结果集。 注意：单纯的select * from a,b是笛卡尔乘积。比如a表有5条数据，b表有3条数据，那么最后的结果有5*3=15条数据。 但是如果对两个表进行关联:select * from a,b where a.id = b.id 意思就变了，此时就等价于： select * from a inner join b on a.id = b.id。即就是内连接。 但是这种写法并不符合规范，可能只对某些数据库管用，如sqlserver。推荐最好不要这样写。最好写成inner join的写法。 2.left join,在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。 3.right join,在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。 4.full join,在两张表进行连接查询时，返回左表和右表中所有没有匹配的行。 查询结果是left join和right join的并集。 二、多对多关系建表其实不用外键约束 看B站视频，网页说什么阿里官方禁止，说了一大堆缺点，效率低，限制多，可以有外键，只是代码里他们说在service层控制约束，多对多关系也可以写成一对多关系，在一方实体里写对方的集合，数据库里建中间表，但实体里可以不写，只是在查询代码里用连接查询就行。 ","link":"https://eric-tom.github.io/post/shu-ju-ku-xiang-guan-zhi-shi/"},{"title":"一些Springboot笔记","content":"1.@RequestMapping 和 @GetMapping @PostMapping 区别 @GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。 @PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。 @RequestMapping: 一般情况下都是用@RequestMapping（method=RequestMethod.），因为@RequestMapping可以直接替代以上两个注解，但是以上两个注解并不能替代@RequestMapping，@RequestMapping相当于以上两个注解的父类！ 类似的组合注解还有： @PutMapping、@DeleteMapping、@PatchMapping 总结下来就是@PostMapping和@GetMapping都可以用@RequestMapping代替，如果读者怕在映射的时候出错，可以统一写@RequestMapping，当然这样写的话也有弊端，笼统的全用@RequestMapping, 不便于其他人对代码的阅读和理解！还是建议区分开来写！养成良好的代码习惯！ 2.@Accessors(chain = true) 在entitiy的类中加上，链式编程，链式访问，该注解设置chain=true，生成setter方法返回this（也就是返回的是对象），代替了默认的返回void。 好处如对一个对象连续设置属性， Apple apple = new Apple(); apple.setColor(&quot;red&quot;).setFlag(true).setHeight(22.56);//链式 3.@Data注解 与 lombok 常用的几个注解： @Data ： 注在类上，提供类的get、set、equals、hashCode、canEqual、toString方法 @AllArgsConstructor ： 注在类上，提供类的全参构造 @NoArgsConstructor ： 注在类上，提供类的无参构造 @Setter ： 注在属性上，提供 set 方法 @Getter ： 注在属性上，提供 get 方法 @EqualsAndHashCode ： 注在类上，提供对应的 equals 和 hashCode 方法 @Log4j/@Slf4j ： 注在类上，提供对应的 Logger 对象，变量名为 log 4.entity中的类有Date属性时，插入入的时间是String类型，需要转换为Date @DateTimeFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;) 入参格式化，页面写入数据库时格式化, @DateTimeFormat 注解的 pattern 属性值指定的日期时间格式并不是将要转换成的日期格式，这个指定的格式是和传入的参数对应的。 @JsonFormat @JsonFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;,locale=&quot;zh&quot;,timezone=&quot;GMT+8&quot;) 出参格式化， ","link":"https://eric-tom.github.io/post/yi-xie-bi-ji/"},{"title":"努力加油吧!","content":"学习学习ing~! &quot;The best time to plant a tree is 10 years ago. The second-best time is now.&quot; 种一棵树最好的时间是十年前，其次是现在。 ","link":"https://eric-tom.github.io/post/nu-li-jia-you-ba/"},{"title":"Gridea 一个简单、开源、强大的静态博客写作客户端!","content":"一、介绍 Gridea（旧称 Hve Notes）是一个静态博客写作客户端 (A static blog writing client) ，你可以用它来记录你的生活、心情、知识、笔记、创意等。配合 github账号你可以搭建一个静态页面的博客，界面简洁美观，写作推送非常的方便，非常适合小白。 瞬移：Gridea 二、特性 Markdown Gridea 提供了 Markdown 编辑体验，你可以专注内容，其他的，交给 Gridea 就够了，无需关心样式与排版。 封面图 一篇用心的创作，怎么能不搭配一个封面图来锦上添花呢？有！Gridea 支持文章设置封面图，即使是外链图也不成问题。 自定义标签 我们更建议使用标签来为文章进行归类，以你最喜欢的方式：编程、旅行、读书笔记... 我们并没有同时提供标签和类别两层分类关系，画繁为简，不必纠结。 自定义菜单 我们开发了自定义菜单功能，同时贴心地准备了主页、归档、标签列表等快捷选择。当然，你也可以创建外部菜单到互联网的任何一个地方。 多主题 我们内置了 4 款主题，还有更多主题曲管网下载，制作精良、耐看，更有趣的是，我们为每款主题设置了丰富的自定义配置字段，稍加配置，遇见大不同 跨设备 或许你工作使用 Mac，生活使用 Windows，这都不是事儿，Gridea 全都支持！同时支持更改源文件夹，利用 OneDrive、Dropbox 等同步工具，跨设备管理博客轻而易举！什么，你喜欢用 Linux？再等等，稍后就来 多平台 大部分情况下你用 Github Pages 来托管博客就够了，但我们同时提供了 Coding Pages 的支持。若你想部署在自己的服务器，可将构建后的网站上传到任意地方。我想，未来会将这一过程变得更加流畅 多评论 Gridea 内置了 Gitalk 和 Disqus 两个评论系统，你可以任选其一，利用评论结交更多朋友吧！ 多语言 是的，我们贴心地为你内置了中文简体和 English 两种语言。 多平台部署 支持多平台 Mac / Win / Linux ，界面优雅 当然 Gridea 还很年轻，有很多不足的地方，但请相信，它会不停向前。未来，它一定会成为爱创作的你离不开的伙伴。搭建过程可以去管网或B站寻找。 零门槛 / 快速 / 精简 / 清爽 😀 / 😃 / 😄 / 😋 / 😜 / 😝 ","link":"https://eric-tom.github.io/post/gridea-xie-bo-ke/"},{"title":"Hello Gridea!","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://eric-tom.github.io/post/hello-gridea/"}]}