<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>算法与数据结构（C++） | Welcome to Eric&#39;s blog!</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://eric-tom.github.io/favicon.ico?v=1630677499282">
<link rel="stylesheet" href="https://eric-tom.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="此部分非常非常重要，同时特特特难!


从今天开始j记录相关知识！加油！
如何选择编程语言和编译器？
其实都可以，看个人爱好，我个人首次接触的编程语言是C++，所以常用便习惯了。
很多考试都会限定程序的运行时间的上限,因此选择尽可能快的编程..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://eric-tom.github.io">
        <img src="https://eric-tom.github.io/images/avatar.png?v=1630677499282" class="site-logo">
        <h1 class="site-title">Welcome to Eric&#39;s blog!</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      醉翁之意不在酒
    </div>
    <div class="site-footer">
      <a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=t4aGh4aCgIGHhoH3xsaZ1Nja" style="text-decoration:none;"><img src="http://rescdn.qqmail.com/zh_CN/htmledition/images/function/qm_open/ico_mailme_21.png"/></a> | <a class="rss" href="https://eric-tom.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">算法与数据结构（C++）</h2>
            <div class="post-date">2021-09-03 15-09</div>
            
              <div class="feature-container" style="background-image: url('https://eric-tom.github.io/post-images/suan-fa-yu-shu-ju-jie-gou-c.jpg')">
              </div>
            
            <div class="post-content" v-pre>
              <p>此部分非常非常重要，同时特特特难!</p>
<!-- more -->
<ul>
<li>从今天开始j记录相关知识！加油！</li>
<li>如何选择编程语言和编译器？</li>
<li>其实都可以，看个人爱好，我个人首次接触的编程语言是C++，所以常用便习惯了。</li>
<li>很多考试都会限定程序的运行时间的上限,因此选择尽可能快的编程语言是非常重要的。一般来说，可供选择的语言有C、C++、Java等，但是Java的执行比较慢，因此较常使用的是C或C++。考虑到C++的语法向下兼容C，并且C的输入输出语句比C++的要快很多，因此我们可以在主体上使用C语言的语法;而C++中有一些特性和功能非常好用（例如变量可以随时定义、拥有标准模板库STL等)，因此在一定程度上我们可以混用部分C++的语法(事实上，由于C++向下兼容C，因此一般都是在C++中写C语言的语法)。</li>
<li>编译器的选择则因人而异、因现场环境而异。不同的考试可能提供不同的编译器，要根据具体情况来选择。但一般来说，可能出现的编译器有VC 6.0、VS系列、Dev-C++、C-Free.Code:Blocks、Eclipse、Idea等，其中VC 6.0因为标准过于古老，很多语法在其中没办法通过编译，所以尽量不要使用;Dev-C++、C-Free、Code::Blocks则是轻便好用的编译器，推荐使用，可以根据具体情况来选择;VS系列是较为厚重的编译器，在没有其他轻便编译器可供选择的情况下使用;Eclipse、Idea则更常用于Java代码的编写。</li>
</ul>
<h1 id="第一节-时间复杂度和空间复杂度">第一节 时间复杂度和空间复杂度</h1>
<hr>
<h2 id="一-算法的时间复杂度定义">一、算法的时间复杂度定义</h2>
<ul>
<li>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度。记作：T(n)=O(f(n))。它表示随问题n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中，f(n)是问题规模n的某个函数。</li>
<li>这样用大写O()来体现算法时间复杂度的记法，我们称之为大0记法。</li>
</ul>
<h2 id="二-推导大o阶方法">二、推导大O阶方法</h2>
<ol>
<li>用常数1取代运行时间中的所有加法常数。</li>
<li>在修改后的运行次数函数中，只保留最高阶项。</li>
<li>如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。</li>
</ol>
<h2 id="三-推导示例">三、推导示例</h2>
<ul>
<li>常数阶<br>
首先顺序结构的时间复杂度。下面这个算法，是利用高斯定理计算1，2，……n个数的和。<br>
int sum = 0, n = 100;       /<em>执行一次</em>/<br>
sum = (1 + n) * n / 2;      /<em>执行一次</em>/<br>
printf(&quot;%d&quot;,sum);           /<em>执行一次</em>/<br>
这个算法的运行次数函数是f (n)  =3。 根据我们推导大0阶的方法，第一步就是把常数项3 改为1。在保留最高阶项时发现，它根本没有最高阶项，所以这个算法的时间复杂度为0(1)。</li>
<li>另外，我们试想一下，如果这个算法当中的语句 sum = (1+n)*n/2; 有10 句，则与示例给出的代码就是3次和12次的差异。这种与问题的大小无关（n的多少），执行时间恒定的算法，我们称之为具有O(1)的时间复杂度，又叫常数阶。对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着n 的变大而发生变化，所以单纯的分支结构(不包含在循环结构中)，其时间复杂度也是0(1)。</li>
</ul>
<h2 id="四-常见的时问复杂度如表所示">四、常见的时问复杂度如表所示。</h2>
<p><img src="https://s3.bmp.ovh/imgs/2021/09/1a27c7f4b188e499.png" alt="时间复杂度表" title="时间复杂度表" loading="lazy"><br>
常用的时间复杂度所耗费的时间从小到大依次是：<br>
O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</p>
<h2 id="五-最坏情况与平均情况">五、最坏情况与平均情况</h2>
<ul>
<li>我们查找一个有n 个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为O(1)，但也有可能这个数字就在最后一个位置上待着，那么算法的时间复杂度就是O(n)，这是最坏的一种情况了。</li>
<li>最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。 在应用中，这是一种最重要的需求， 通常， 除非特别指定， 我们提到的运行时间都是最坏情况的运行时间。</li>
<li>而平均运行时间也就是从概率的角度看， 这个数字在每一个位置的可能性是相同的，所以平均的查找时间为n/2次后发现这个目标元素。平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。也就是说，我们运行一段程序代码时，是希望看到平均运行时间的。可现实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。一般在没有特殊说明的情况下，都是指最坏时间复杂度。</li>
</ul>
<h2 id="六-算法空间复杂度">六、算法空间复杂度</h2>
<ul>
<li>我们在写代码时，完全可以用空间来换取时间，比如说，要判断某某年是不是闰年，你可能会花一点心思写了一个算法，而且由于是一个算法，也就意味着，每次给一个年份，都是要通过计算得到是否是闰年的结果。 还有另一个办法就是，事先建立一个有2050个元素的数组(年数略比现实多一点)，然后把所有的年份按下标的数字对应，如果是闰年，此数组项的值就是1，如果不是值为0。这样，所谓的判断某一年是否是闰年，就变成了查找这个数组的某一项的值是多少的问题。此时，我们的运算是最小化了，但是硬盘上或者内存中需要存储这2050个0和1。这是通过一笔空间上的开销来换取计算时间的小技巧。到底哪一个好，其实要看你用在什么地方。</li>
<li>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作:S(n)= O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。</li>
<li>一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元，若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为0(1)。</li>
<li>通常， 我们都使用&quot;时间复杂度&quot;来指运行时间的需求，使用&quot;空间复杂度&quot;指空间需求。当不用限定词地使用&quot;复杂度'时，通常都是指时间复杂度。</li>
</ul>
<h2 id="七-一些计算的规则">七、一些计算的规则</h2>
<ol>
<li>加法规则<br>
T(n,m) = T1(n) + T2(m) = O(max{f(n), g(m)})</li>
<li>乘法规则<br>
T(n,m) = T1(n) * T2(m) = O(max{f(n)*g(m)})</li>
<li>一个经验<br>
复杂度与时间效率的关系：<br>
c(常数) &lt; logn &lt; n &lt; n*logn &lt; n^2 &lt; n^3 &lt; 2^n &lt; 3^n &lt; n!<br>
|----------------------------|-----------------------|-------------|<br>
|----------- 较好----------|--------一般 --------|----较差----|</li>
</ol>
<h2 id="八-常用算法的时间复杂度和空间复杂度">八、常用算法的时间复杂度和空间复杂度</h2>
<figure data-type="image" tabindex="1"><img src="https://s3.bmp.ovh/imgs/2021/09/e2c0795af0fa9c79.jpg" alt="" loading="lazy"></figure>
<ul>
<li>OJ上的题目一般都有对运行时间和空间的说明，例如：<br>
Time Limit:2000/1000ms(Java/Others)<br>
Memory Limit:65536/65536KB(Java/Others)</li>
</ul>
<pre><code>#include &lt;bits/stdc+t.h&gt;
using namespace std;
int main( )
{
    int i,k,n = 1e8;
    clock_t start,end;
    start = clock( );
    for(i = 0; i&lt;n; i++)k++; //循环次数
    end = clock( ) ;
    cout &lt;&lt;( double)( end - start) / CLOCKS_PER_SEC&lt;&lt;endl;
}
</code></pre>
<ul>
<li>上面的程序在一台普通配置的计算机运行，例如CPU为i5-8250U、内存为8GB、64位的操作系统，结果如下：<br>
当n=1e8=(10<sup>8</sup>)时,输出的运行时间是0.164s。<br>
当n=le9时,输出的运行时间是1.645s。<br>
评测用的OJ服务器,性能可能比这个好一些,也可能差不多。</li>
<li>所以,如果题目要求“Time Limit : 2000/1000ms(Java/Others)”,那么内部的循环次数应该满足n≤(10<sup>8</sup>),即1亿次以内。<br>
由于程序的运行时间依赖于计算机的性能,不同的计算机结果不同,所以直接把运行时间作为判断标准并不准确。通常,用程序执行的“次数”来衡量更加合理,例如上述程序循环了n次,把它的运行效率记为O(n)。</li>
</ul>
<h2 id="九-避免算法竞赛超时小技巧">九、避免算法竞赛超时小技巧</h2>
<ol>
<li>输入输出不用printf()和scanf()的话，加入y下面提高输入输出速度。</li>
</ol>
<pre><code>ios::sync_with_stdio(false);
cin.tie(0);cout.tie(0);
</code></pre>
<ol start="2">
<li>判断奇偶数的时候，使用’&amp;'更高效<br>
在判断一个数的奇数还是偶数的时候，很多小伙伴会使用%来求一个数除以2的余数来进行判断，其实这里我们有更高效的方法，那就是&amp;与运算，如果a&amp;1 == 1则a为奇数，a&amp;1 == 0则a为偶数。</li>
<li>能转换为迭代的函数，尽量不要写递归</li>
<li>算法最高不要超过O(n^2)<br>
在我们正常的算法竞赛中，当你写出来一个时间复杂度比O(n2)的算法时，那你这题基本是凉透了，或者说你只想拿前两个样例(如果是按测试点的比赛，如果实在想不出来，最后可以写个完全暴力，能骗几分是几分)。一般来说，时间效率到O(n 2)一般都很高了，已经很难过全部样例了，如果是压轴题的话，O(n)算法都比较难过全部样例，得需要优化到O(lgn)才保险。</li>
<li>学会以空间换时间<br>
在算法竞赛中，我们一般会经常超出时间限制，但是超出空间限制的还是很少的，一般比赛给的都是16MB甚至256MB，根本用不完啊，而且多开几个数组也完全的占不了几个字节，但是这能让我们的程序节省上百倍的时间。这里就拿昨天写的一题来举例吧：LeetCode 每日一题 42. 接雨水,原文有具体的题目和代码，这里为了方便，我们把两段代码分别拿过来。</li>
<li>leetcode后期的题目，都会告诉你各个变量的取值范围，这个是非常重要的信息点，如果你题目做多了，就会发现，取值范围其实就暗示着作者想让你用什么样的算法。<br>
N～16:    可以用指数O(2^N)的算法<br>
N～100:    指数算法会爆炸，必须要用多项式算法。<br>
N～500:   时间复杂度不能高于O(N^3)<br>
N～2000:  时间复杂度不能高于O(N^2)<br>
N～10^5:  时间复杂度不能高于O(N log N)<br>
N～10^9:  时间复杂度必须为O(log N)或者 O(sqrt(N))<br>
有那么一个公式，就是你的总计算次数不能超过10^7数量级，否则就会超时。这个在任何的编程竞赛中都适用。</li>
<li>问题规模和可用算法<br>
<img src="https://s3.bmp.ovh/imgs/2021/09/daf075bae4e25278.png" alt="" loading="lazy"></li>
<li>多项式函数与指数函数的增长对比<br>
<img src="https://s3.bmp.ovh/imgs/2021/09/940e5ea82087dfe4.png" alt="" loading="lazy"></li>
</ol>
<h1 id="第二节-c标准模板库standard-template-library">第二节 C++标准模板库（Standard Template Library）</h1>
<ul>
<li>常用的数据结构、算法，能极大地简化编程。</li>
</ul>
<h2 id="一-概述">一、概述</h2>
<ul>
<li>在 ACM 竞赛中，需要用到数组、字符串、队列、堆栈、链表、平衡二叉检索树等数<br>
据结构和排序、搜索等算法，以提高程序的时间、空间运行效率。这些数据结构，如果都<br>
需要手工来编写，那是相当麻烦的事情。</li>
<li>幸运的是，ANSI C++中包含了一个 C++ STL（Standard Template Library），即 C++<br>
标准模板库，又称 C++泛型库，它在 std 命名空间中定义了常用的数据结构和算法，使用<br>
起来十分方便。</li>
</ul>
<h2 id="二-cstl组件">二、C++STL组件</h2>
<ul>
<li>STL 提供三种类型的组件：容器、迭代器和算法，它们都支持泛型程序设计标准。
<ul>
<li>容器主要有两类：顺序容器和关联容器。顺序容器（vector、list、deque 和 string<br>
等）是一系列元素的有序集合。关联容器（set、multiset、map和multimap）包含查找元素的键值。<br>
迭代器的作用是遍历容器。</li>
<li>STL 算法库包含四类算法：排序算法、不可变序算法、变序性算法和数值算法。</li>
</ul>
</li>
</ul>
<h3 id="1vector">1.vector</h3>
<ol>
<li>概述</li>
</ol>
<ul>
<li>数组：算法竞赛中，为避免出错，一般用静态数组，而不用指针管理动态数组。能开多大就开多大：<br>
<code>int a[1000000], dp[1000000];</code></li>
<li>如果空间紧张，用STL的vector建立动态数组，不仅节约空间，也不易出错。</li>
<li>Vector：动态数组，运行时根据需要改变数组大小。</li>
<li>以数组形式存储，内存空间是连续的，索引可以在常数时间内完成。</li>
<li>但是在中间进行插入和删除操作，会造成内存块的拷贝。</li>
</ul>
<ol start="2">
<li>定义</li>
</ol>
<ul>
<li>vector容器能存放任何类型的对象<br>
<img src="https://s3.bmp.ovh/imgs/2021/09/0d1d6de679db6604.png" alt="" loading="lazy"></li>
<li>多维数组</li>
<li>定义多维数组，例如定义一个二维数组：<br>
<code>vector&lt;int&gt; a[MAXN];</code></li>
<li>它的第一维大小是固定的MAXN，第二维是动态的。</li>
<li>用这个方式，可以实现图的邻接表存储。</li>
</ul>
<ol start="3">
<li>常用操作<br>
<img src="https://s3.bmp.ovh/imgs/2021/09/eb69f55171b283d4.png" alt="" loading="lazy"></li>
<li>例：hdu 4841圆桌问题</li>
</ol>
<ul>
<li>圆桌上围坐着2n个人。其中n个人是好人，另外n个人是坏人。从第一个人开始数数，数到第m个人，立即赶走该人；然后从被赶走的人之后开始数数，再将数到的第m个人赶走……依此方法不断赶走围坐在圆桌上的人。</li>
<li>预先应如何安排这些好人与坏人的座位，能使得在赶走n个人之后，圆桌上围坐的剩余的n个人全是好人？</li>
<li>约瑟夫问题。用vector模拟动态变化的圆桌。</li>
</ul>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
    vector &lt;int&gt; table;                          //模拟圆桌
    int n, m;
    while(cin &gt;&gt; n &gt;&gt; m){
        table.clear();
        for(int i=0; i&lt;2*n; i++)  table.push_back(i);  //初始化
        int pos = 0;                               //记录当前位置
        for(int i=0; i&lt;n; i++){                  //赶走n个
            pos = (pos+m-1) % table.size();    //圆桌是个环，取余处理
            table.erase(table.begin() + pos); //赶走坏人，table人数减1
        }
        int j = 0;  
        for(int i=0; i&lt;2*n; i++){               //打印预先安排座位
            if(!(i%50) &amp;&amp; i)  cout&lt;&lt;endl;       //50个字母一行
            if(j&lt;table.size() &amp;&amp; i==table[j]){ //table留下的都是好人
                j++; 
                cout&lt;&lt;&quot;G&quot;;
            }
            else   
               cout&lt;&lt;&quot;B&quot;;
        }
        cout&lt;&lt;endl&lt;&lt;endl;                          //留一个空行
    }
    return 0;
}
</code></pre>
<h3 id="2栈和stack">2.栈和stack</h3>
<p>栈：基本的数据结构之一，特点是“先进后出”。</p>
<ul>
<li>栈的有关操作<br>
<img src="https://s3.bmp.ovh/imgs/2021/09/dc2666441a4f4084.png" alt="" loading="lazy"></li>
</ul>
<h3 id="3队列和queue">3.队列和queue</h3>
<p>队列：基本的数据结构之一，特点是“先进先出”。</p>
<ul>
<li>队列的有关操作<br>
<img src="https://s3.bmp.ovh/imgs/2021/09/c22b443a7426f70d.png" alt="" loading="lazy"></li>
</ul>
<h3 id="4优先队列和priority_queue">4.优先队列和priority_queue</h3>
<p>优先队列：优先级最高的先出队。<br>
队列和排序的完美结合，不仅可以存储数据，还可以将这些数据按照设定的规则进行排序。<br>
每次的push和pop操作，优先队列都会动态调整，把优先级最高的元素放在前面。</p>
<ul>
<li>优先队列的有关操作
<ul>
<li>q.top();　 //返回具有最高优先级的元素值，但不删除该元素</li>
<li>q.pop();     //删除最高优先级元素</li>
<li>q.push(item) ;  //插入新元素</li>
</ul>
</li>
<li>STL中，优先队列是用二叉堆来实现的，往队列中push入一个数或pop一个数，复杂度是O(logn)。<br>
例：图论的Dijkstra算法的程序实现，用STL的优先队列能极大地简化代码。</li>
</ul>
<h3 id="5链表和list">5.链表和list</h3>
<p>STL的 list ：双向链表。它的内存空间不必连续，通过指针来进行数据的访问，高效率地在任意地方删除和插入，插入和删除操作是常数时间。<br>
list和vector的优缺点正好相反，它们的应用场景不同：<br>
（1）vector：插入和删除操作少，随机访问元素频繁；<br>
（2）list：插入和删除频繁，随机访问较少。</p>
<h3 id="6set集合容器">6.set集合容器</h3>
<ul>
<li>STL的set用二叉搜索树实现，集合中的每个元素只出现一次，且是排好序的。访问元素的时间复杂度是O(logn)的。</li>
<li>set和map在竞赛题中应用很广泛。特别是需要用二叉搜索树处理数据的题目，如果用set或map实现，能极大地简化代码。</li>
</ul>
<pre><code>#include &lt;set&gt;
set&lt;int&gt; s;
s.insert(8);//第一次插入 8，可以插入
s.insert(1);
s.insert(12);
s.insert(6);
s.insert(8);//第二次插入 8，重复元素，不会插入
//删除键值为 6 的那个元素
s.erase(6);
it=s.find(6);
if(it!=s.end())//找到
cout&lt;&lt;*it&lt;&lt;endl;
else//没找到
cout&lt;&lt;&quot;not find it&quot;&lt;&lt;endl;
//中序遍历集合中的元素
set&lt;int&gt;::iterator it;//定义前向迭代器
//中序遍历集合中的所有元素
for(it=s.begin();it!=s.end();it++)
{
    cout&lt;&lt;*it&lt;&lt;&quot; &quot;;
}
</code></pre>
<h3 id="7multiset">7.multiset</h3>
<p>multiset 允许重复的元素键值插入</p>
<pre><code>#include &lt;set&gt;
//定义元素类型为 string 的多重集合对象 s，当前没有任何元素
multiset&lt;string&gt; ms;
ms.insert(&quot;abc&quot;);
ms.insert(&quot;123&quot;);
ms.insert(&quot;111&quot;);
ms.insert(&quot;aaa&quot;);
ms.insert(&quot;123&quot;);
//删除值为“123”的所有重复元素，返回删除元素总数 2
int n=ms.erase(&quot;123&quot;);
</code></pre>
<h3 id="8map-映照容器">8.map 映照容器</h3>
<ul>
<li>map：关联容器，实现从键（key）到值（value）的映射。</li>
<li>map效率高的原因：用平衡二叉搜索树来存储和访问。</li>
</ul>
<pre><code>#include &lt;map&gt;
在没有指定比较函数时，元素的
插入位置是按键值由小到大插入到黑白树中去的，这点和 set 一样。
map&lt;string,float&gt; m;
//插入元素，按键值的由小到大放入黑白树中
m[&quot;Jack&quot;]=98.5;
m[&quot;Bomi&quot;]=96.0;
m[&quot;Kate&quot;]=97.5;
//前向遍历元素
map&lt;string,float&gt;::iterator it;
for(it=m.begin();it!=m.end();it++)
{
    //输出键值与映照数据
    cout&lt;&lt;(*it).first&lt;&lt;&quot; : &quot;&lt;&lt;(*it).second&lt;&lt;endl;
}
运行结果：
Bomi : 96
Jack : 98.5
Kate : 97.5

//反向遍历元素
map&lt;int,char&gt;::reverse_iterator rit;
for(rit=m.rbegin();rit!=m.rend();rit++)
{
    //输出键值与映照数据
    cout&lt;&lt;(*rit).first&lt;&lt;&quot; : &quot;&lt;&lt;(*rit).second&lt;&lt;endl;
}
return 0;
//删除键值为 28 的元素
m.erase(28);
it=m.find(28);
if(it!=m.end())//搜索到该键值
{
    cout&lt;&lt;(*it).first&lt;&lt;&quot; : &quot;&lt;&lt;(*it).second&lt;&lt;endl;
}
else
{
    cout&lt;&lt;&quot;not found it&quot;&lt;&lt;endl;
}

用 map 实现数字分离
对数字的各位进行分离，采用取余等数学方法操作是很耗时的。而把数字当成字符串，
使用 map 的映照功能，很方便地实现了数字分离。下面这个程序将一个字符串中的字符当
成数字，并将各位的数值相加，最后输出各位的和。
#pragma warning(disable:4786)
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;iostream&gt;
using namespace std;
int main(int argc, char* argv[])
{
    //定义 map 对象，当前没有任何元素
    map&lt;char,int&gt; m;
    //赋值:字符映射数字
    m['0']=0;
    m['1']=1;
    m['2']=2;
    m['3']=3;
    m['4']=4;
    m['5']=5;
    m['6']=6;
    m['7']=7;
    m['8']=8;
    m['9']=9;
    /*上面的 10 条赋值语句可采用下面这个循环来简化代码编写
    for(int j=0;j&lt;10;j++)
    {
    m['0'+j]=j;
    }
    */
    string sa,sb;
    sa=&quot;6234&quot;;
    int i;
    int sum=0;
    for(i=0;i&lt;sa.length();i++)
    {
        sum+=m[sa[i]];
    }
    cout&lt;&lt;&quot;sum = &quot;&lt;&lt;sum&lt;&lt;endl;
    return 0;
}
运行结果：
sum = 15

2.6.7 数字映照字符的 map 写法
在很多情况下，需要实现将数字映射为相应的字符，看看下面这个程序：
#pragma warning(disable:4786)
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;
int main(int argc, char* argv[])
{
    //定义 map 对象，当前没有任何元素
    map&lt;int,char&gt; m;
    //赋值:字符映射数字
    m[0]='0';
    m[1]='1';
    m[2]='2';
    m[3]='3';
    m[4]='4';
    m[5]='5';
    m[6]='6';
    m[7]='7';
    m[8]='8';
    m[9]='9';
    /*上面的 10 条赋值语句可采用下面这个循环来简化代码编写
    for(int j=0;j&lt;10;j++)
    {
    m[j]='0'+j;
    }
    */
    int n=7;
    string s=&quot;The number is &quot;;
    cout&lt;&lt;s + m[n]&lt;&lt;endl;
    return 0;
}
运行结果：
The number is 7
</code></pre>
<h3 id="9multimap-多重映照容器">9.multimap 多重映照容器</h3>
<h3 id="10sort">10.sort</h3>
<ul>
<li>STL的排序函数sort()：算法竞赛中最常用的函数之一</li>
<li>定义有两种：<br>
void sort (RandomAccessIterator first, RandomAccessIterator last);<br>
void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);<br>
返回值：无。<br>
复杂度：O(nlogn)。</li>
</ul>
<p>它排序的范围是[first, last)，包括first，不包括last。</p>
<h3 id="11next_permutation">11.next_permutation</h3>
<ul>
<li>next_permutation()： 求“下一个”排列组合。</li>
<li>例如三个字符{a, b, c}组成的序列，next_permutation()能按字典序返回6个组合：abc，acb，bac，bca，cab，cba。</li>
<li>函数next_permutation()的定义有两种形式：<br>
bool next_permutation (BidirectionalIterator first, BidirectionalIterator last);<br>
bool next_permutation (BidirectionalIterator first, BidirectionalIterator last, Compare comp);<br>
返回值：如果没有下一个排列组合，返回false，否则返回true。每执行next_permutation()一次，会把新的排列放到原来的空间里。<br>
复杂度：O(n)。</li>
<li>排列的范围：[first, last)，包括first，不包括last。</li>
</ul>
<h1 id="第二节-排序算法">第二节 排序算法</h1>
<ul>
<li>十大排序算法</li>
<li><img src="https://s3.bmp.ovh/imgs/2021/09/1a419363a97ccee4.png" alt="" loading="lazy"></li>
</ul>
<h2 id="一-插入排序-直接插入排序">一、插入排序－直接插入排序</h2>
<h3 id="1时空复杂度">1.时空复杂度</h3>
<h3 id="2算法实现">2.算法实现</h3>
<h2 id="二-插入排序-折半插入排序">二、插入排序－折半插入排序</h2>
<h3 id="1时空复杂度-2">1.时空复杂度</h3>
<h3 id="2算法实现-2">2.算法实现</h3>
<h2 id="三-插入排序-希尔排序">三、插入排序－希尔排序</h2>
<h3 id="1时空复杂度-3">1.时空复杂度</h3>
<h3 id="2算法实现-3">2.算法实现</h3>
<h2 id="四-交换排序-冒泡排序">四、交换排序－冒泡排序</h2>
<h3 id="1时空复杂度-4">1.时空复杂度</h3>
<p><img src="https://eric-tom.github.io/post-images/1630676066823.png" alt="" loading="lazy"><br>
下面分析程序的时间和空间效率。<br>
(1）时间复杂度,也就是程序执行了多少步骤,花了多少时间。<br>
在bubble _sort()中有两层循环.循环次数具n-1+n-2+...+1≈n2 /2；在swap(a,b)中做了3次操作;总的计算次数是3n2 /2.复杂度记为((n2),当n=100万时,计算超过1万亿次。如果提交到OJ,由于OJ每秒只能运行1亿次,必然返回TLE超时。可以推出,只有n &lt; 1万时才勉强能用冒泡算法。<br>
(2空间复杂度,也就是程序占用的内存空间。程序使用int a[1000001]存储数据，bubble_sort()也没有使用额外的空间。int是32位整数﹐占用4个字节,所以int a[1000001]共使用了4MB空间。这是冒泡算法的优点,它不额外占用空间。</p>
<h3 id="2算法实现-4">2.算法实现</h3>
<pre><code>#define swap(a,b){int temp = a ; a = b ; b = temp ;}
int n, m;//输入n个数，排序后从大到小输出前m个,0 &lt; m.n &lt; 1000000,数处于[-500000,500000]的整数
int a[1000001];
void bubble_sort()//冒泡排序
{
	for (int i = 1; i &lt;= n - 1; i++)//共比较n-1次
	{
		for (int j = 1; j &lt;= n - i; j++)//每次比较n-i个，筛选出最大的就不用比了
		{
			if (a[j] &gt; a[j + 1])
				swap(a[j], a[j + 1]);
		}
	}
}
</code></pre>
<h2 id="五-交换排序-快速排序">五、交换排序－快速排序</h2>
<h3 id="1时空复杂度-5">1.时空复杂度</h3>
<p>快速排序是一种基于分治法的优秀排序算法。这里先直接用STL 的 sort()函数,它是改良版的快速排序,称为“内省式排序”。<br>
在上面的程序中,把“bubble sort():”改为“sort(a+1，a+n+1);”就完成了a[1]到a[n的]的排序,结果仍然保存在a中。<br>
算法的时间复杂度是O(nlog2 n),当n=100万时,100万×log:100万≈2000万。在hdu上提交,返回的运行时间是600ms,正好通过OJ的测试。</p>
<h3 id="2算法实现-5">2.算法实现</h3>
<pre><code>#include&lt;iostream&gt;
using namespace std;
int fun(int b[], int low, int high)
{
	b[0] = b[low];
	int standard=b[low];
	while (low &lt; high&amp;&amp;standard &lt;= b[high]) high--;
	b[low] = b[high];
	while (low &lt; high&amp;&amp;standard &gt;= b[low]) low++;
	b[high] = b[low]; 
	b[low] = b[0];
	return low;
}
void QuickSort(int a[],int low,int high)
{
	if (low &gt;= high) return;
	int x = fun(a,low, high);
	QuickSort(a, 1, x - 1);
	QuickSort(a, x+1,high);
}

int main()
{
	int a[11] = { 0,1,8,5,7,6,3,4,9,11,2 };
	QuickSort(a,1,10);
	for (int i = 1; i &lt;= 10; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
	return 0;
}
</code></pre>
<h2 id="六-选择排序-简单选择排序">六、选择排序－简单选择排序</h2>
<h3 id="1时空复杂度-6">1.时空复杂度</h3>
<h3 id="2算法实现-6">2.算法实现</h3>
<h2 id="七-选择排序-树形选择排序">七、选择排序－树形选择排序</h2>
<h3 id="1时空复杂度-7">1.时空复杂度</h3>
<h3 id="2算法实现-7">2.算法实现</h3>
<h2 id="八-选择排序-堆排序">八、选择排序－堆排序</h2>
<h3 id="1时空复杂度-8">1.时空复杂度</h3>
<h3 id="2算法实现-8">2.算法实现</h3>
<h2 id="九-归并排序">九、归并排序</h2>
<h3 id="1时空复杂度-9">1.时空复杂度</h3>
<h3 id="2算法实现-9">2.算法实现</h3>
<h2 id="十-基数排序">十、基数排序</h2>
<h3 id="1时空复杂度-10">1.时空复杂度</h3>
<h3 id="2算法实现-10">2.算法实现</h3>
<h2 id="十一-外部排序">十一、外部排序</h2>
<h3 id="1时空复杂度-11">1.时空复杂度</h3>
<h3 id="2算法实现-11">2.算法实现</h3>
<h1 id="第三节-搜索技术">第三节 搜索技术</h1>
<h2 id="一-排列组合问题">一、排列组合问题</h2>
<h3 id="1介绍">1.介绍</h3>
<p>排列和组合问题是在暴力枚举的时候经常遇到的,一般有3种常见情况,<br>
问题1:打印n个数的全排列,共n!个。<br>
问题2:打印n个数中任意m个数的全排列,共n!/(n-m)!个。<br>
问题3:打印n个数中任意m个数的组合,共n!/m!*(n-m)!个。<br>
一个包含n个元素的集合它的子集有2n个。每个子集可以认为对应一个二进制数，如n=3的集合{a0,a1,a2}，∅为000，a0为001。<br>
n个数中任意m个数的组合,转化查找1的个数为k的二进制数，一种方法逐位查找，查找n次，另一种更快，另外有一个更快的方法,它可以直接定位二进制数中1的位置,跳过中间的0。它用到个神奇的操作——kk=kk &amp;.(k-1),功能是消除k的二进制数的最后一个1。连续进行这个操作,每次消除一个1,直到全部消除为止,操作次数就是1的个数。例如二进制数1011,经过连续3次操作后,所有的1都消除了：<br>
1011 &amp;(1011—1)=1011 &amp;.1010=1010<br>
1010 &amp; (1010-1)-1010 &amp;1001=1000<br>
1000 &amp; （1000-1)=1000 &amp; 0111=0000<br>
利用这个操作可以计算出二进制数中1的个数。用num 统计1的个数,具体步骤如下:<br>
(1)用kk=kk&amp;(kk-1)清除kk的最后一个1。(2) num++。<br>
(3）继续上述操作,直到kk=0。</p>
<h3 id="2代码">2.代码</h3>
<pre><code>#include &lt;bits\stdc++.h&gt;
using namespace std;
#define Swap(a,b) {char temp=b;b=a;a=temp;}
int num=0;
//char data[]=&quot;5214&quot;;
char data[]=&quot;abcd&quot;;
//问题1:打印n个数的全排列,共n!个。
void APmtSTL(int s,int t)//对数组data从第s个到第t个进行全排序STL
{
    sort(data+s-1,data+t);
    int  order=1;
    do
    {
        cout&lt;&lt;order++&lt;&lt;&quot;: \t&quot;;
        for(int i=s-1;i&lt;t;i++)
        {
            cout&lt;&lt;data[i]&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
        num++;

    }while(next_permutation(data+s-1,data+t));

}
void PmtRcs(int s,int t)//PermutationRecursion,对数组data从第s个到第t个进行全排序递归
{
    if(s==t)
    {
        num++;//这是一次最终递归的结束位置，可以操作一些东西
        for(int i=0;i&lt;4;i++)
        {
            cout&lt;&lt;data[i]&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
    }
    else
    {
        for(int i=s-1;i&lt;t;i++)
        {
            Swap(data[s-1],data[i]);//把当前第一个数与后面所有数交换
            PmtRcs(s+1,t);
            Swap(data[s-1],data[i]);//恢复用于下一次交换
        }

    }
}
//问题2:打印n个数中任意m个数的全排列,共n!/(n-m)!个。比如在10个数中任取3个数进行全排列，把end改为3，判断改就行了
void PmtRcs2(int s,int t)//对数组data从第s个到第t个进行10选3全排序递归
{
    if(s==3)
    {
        num++;//这是一次最终递归的结束位置，可以操作一些东西
        for(int i=0;i&lt;3;i++)
        {
            cout&lt;&lt;data[i]&lt;&lt;&quot; &quot;;
        }
        cout&lt;&lt;endl;
    }
    else
    {
        for(int i=s-1;i&lt;t;i++)
        {
            Swap(data[s-1],data[i]);//把当前第一个数与后面所有数交换
            PmtRcs2(s+1,t);
            Swap(data[s-1],data[i]);//恢复用于下一次交换
        }

    }
}
//问题3:打印n个数中任意m个数的组合,共n!/m!*(n-m)!个。
void SubSet(int n)//求包含n个元素的子集数
{
    int emptySet;
    for(int i=0;i&lt;(1&lt;&lt;n);i++)
    {
        emptySet=1;
        for(int j=0;j&lt;n;j++)
        {
            if(i&amp;(1&lt;&lt;j))
            {
                emptySet=0;
                cout&lt;&lt;data[j]&lt;&lt;&quot; &quot;;
            }
        }
        if(emptySet)  cout&lt;&lt;&quot;Φ&quot;;
        cout&lt;&lt;endl;
    }
    num=1&lt;&lt;n;
    cout&lt;&lt;&quot;集合数为&quot;&lt;&lt;n&lt;&lt;&quot;，有&quot;&lt;&lt;num&lt;&lt;&quot;个子集&quot;&lt;&lt;endl;
}
void SubSet2(int n,int k)//n个数中任意m个数的组合
{
    int emptySet;
    int kk;
    int num1;
    for(int i=0;i&lt;(1&lt;&lt;n);i++)
    {
        num1=0;//计算1的个数
        kk=i;
        emptySet=1;
        while(kk)
        {
            kk=kk&amp;(kk-1);//消除一个1
            num1++;
        }
        if(num1==k)
        {
            num++;
            for(int j=0;j&lt;n;j++)
            {
                if(i&amp;(1&lt;&lt;j))
                {
                    emptySet=0;
                    cout&lt;&lt;data[j]&lt;&lt;&quot; &quot;;
                }
            }
            if(emptySet) cout&lt;&lt;&quot;Φ&quot;;
            cout&lt;&lt;endl;
        }
    }
    cout&lt;&lt;&quot;从&quot;&lt;&lt;n&lt;&lt;&quot;个选&quot;&lt;&lt;k&lt;&lt;&quot;个的组合，一共&quot;&lt;&lt;num&lt;&lt;&quot;个&quot;&lt;&lt;endl;
}
void Test1(int n)//测试左移
{
    //unsigned int a = 1;
    int a=1 &lt;&lt; n;
    cout&lt;&lt;a&lt;&lt;endl;
}
void Test2(int n)//测试&amp;
{
    int a=6 &amp; n;
    cout&lt;&lt;a&lt;&lt;endl;
}
int main()
{
    /*APmtSTL(1,4);
    cout&lt;&lt;&quot;全排列数：&quot;&lt;&lt;num&lt;&lt;endl;*/
    /*PmtRcs(1,4);
    cout&lt;&lt;&quot;全排列数：&quot;&lt;&lt;num&lt;&lt;endl;*/
    /*PmtRcs2(1,4);
    cout&lt;&lt;&quot;4选3全排列数：&quot;&lt;&lt;num&lt;&lt;endl;*/
    /*int n;
    cin&gt;&gt;n;
    SubSet(n);*/
    int n,k;
    cin&gt;&gt;n&gt;&gt;k;
    SubSet2(n,k);
    return 0;
}
</code></pre>
<h2 id="二-bfs">二、BFS</h2>
<h3 id="1介绍-2">1.介绍</h3>
<p>一般用队列这种数据结构来具体实现BFS</p>
<h3 id="2例题">2.例题</h3>
<p>（1）</p>
<ul>
<li>例题：hdu 1312题<br>
•	一个长方形的房间，铺着方砖，每块砖是 #或黑点. 。<br>
•	一个人站在黑砖上，可以按上、下、左、右方向移动到相邻的砖。<br>
•	他不能在#上移动，他只能在黑砖上移动。<br>
•	起点是@，要求：遍历所有黑点。</li>
<li>代码</li>
</ul>
<pre><code>//ECUST luoyongjun
#include&lt;bits/stdc++.h&gt;
using namespace std;
char room[23][23];
int dir[4][2] = {
    {-1,0},  //向左。左上角坐标是(0, 0)
    {0,-1},  //向上
    {1,0},   //向右
    {0,1}    //向下
};
int Wx, Hy, num;                 //Wx行，Hy列。用num统计可走的位置有多少
#define CHECK(x, y) (x&lt;Wx &amp;&amp; x&gt;=0 &amp;&amp; y &gt;=0 &amp;&amp; y&lt;Hy) //是否在room里
struct node {int x,y;};
void BFS(int dx,int dy){
    num=1;                         //起点也包含在砖块内
    queue &lt;node&gt; q;              //队列中放坐标点
    node start, next;
    start.x = dx;
    start.y = dy;
    q.push(start);
    while(!q.empty()) {
        start = q.front();
        q.pop();
//cout&lt;&lt;&quot;out&quot;&lt;&lt;start.x&lt;&lt;start.y&lt;&lt;endl;    //打印出队列情况，进行验证
        for(int i=0; i&lt;4; i++) { //按左、上、右、下，4个方向顺时针逐一搜索
            next.x = start.x + dir[i][0];
            next.y = start.y + dir[i][1];
            if(CHECK(next.x,next.y) &amp;&amp; room[next.x][next.y]=='.') {
                room[next.x][next.y]='#';           //进队之后，标记为已经处理过
                num++;
                q.push(next);
            }
        }
    }
}
int main(){
    int x, y, dx, dy;
    while (cin &gt;&gt; Wx &gt;&gt; Hy) {   	          //Wx行，Hy列
        if (Wx==0 &amp;&amp; Hy==0)   			 //结束
            break;
        for (y = 0; y &lt; Hy; y++) {         //有Hy列
            for (x = 0; x &lt; Wx; x++) { 	 //一次读入一行
                cin &gt;&gt; room[x][y];
                if(room[x][y] == '@') {     //读入起点
                    dx = x;
                    dy = y;
                }
            }
        }
        num = 0;
        BFS(dx, dy);
        cout &lt;&lt; num &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<p>（2）</p>
<ul>
<li>八数码问题<br>
在一个3×3的棋盘上，放置编号为1~8的8个方块，每个占一格，另外还有一个空格。与空格相邻的数字方块可以移动到空格里。<br>
任务1：指定初始棋局和目标棋局，计算出最少的移动步数；<br>
任务2：输出数码的移动序列。</li>
<li>代码</li>
</ul>
<pre><code>#include&lt;bits/stdc++.h&gt;
const int LEN = 362888;       //状态共9!=362880种
using namespace std;
struct node{
    int state[9];       //记录一个八数码的排列，即一个状态
    int dis;             //记录到起点的距离
};
int dir[4][2] = {{-1,0}, {0,-1},{1,0},{0,1}};
           //左、上、右、下顺时针方向。左上角坐标是(0,0)
int visited[LEN]={0};  //与每个状态对应的记录，Cantor函数对它置数，并判重
int start[9];            //开始状态
int goal[9];             //目标状态
long int factory[] = {1,1,2,6,24,120,720,5040,40320,362880};
                             //Cantor用到的常数
bool Cantor(int str[], int n) {     //用康托展开判重
    long result = 0;
    for(int i = 0; i &lt; n; i++) {
        int counted = 0;
        for(int j = i+1; j &lt; n; j++) {
            if(str[i] &gt; str[j])       //当前未出现的元素中是排在第几个
                ++counted;
        }
        result += counted*factory[n-i-1];
    }
    if(!visited[result]) {            //没有被访问过
        visited[result] = 1;
        return 1;
    }
    else
        return 0;
}
int bfs() {
    node head;
    memcpy(head.state, start, sizeof(head.state));  //复制起点的状态
    head.dis = 0;
    queue &lt;node&gt; q;          //队列中放状态
    Cantor(head.state, 9);  //用康托展开判重，目的是对起点的visited[]赋初值
    q.push(head);             //第一个进队列的是起点状态
    while(!q.empty()) {              //处理队列
        head = q.front();
        q.pop();                       //可在此处打印head.state，看弹出队列的情况
        int z;
        for(z = 0; z &lt; 9; z++)        //找这个状态中元素0的位置
            if(head.state[z] == 0)    //找到了
                break;
            //转化为二维，左上角是原点(0, 0)。
        int x = z%3;          //横坐标
        int y = z/3;          //纵坐标
        for(int i = 0; i &lt; 4; i++){   //上、下、左、右最多可能有4个新状态
            int newx = x+dir[i][0];    //元素0转移后的新坐标
            int newy = y+dir[i][1];
            int nz = newx + 3*newy;    //转化为一维
            if(newx&gt;=0 &amp;&amp; newx&lt;3 &amp;&amp; newy&gt;=0 &amp;&amp; newy&lt;3) {//未越界
                node newnode;
                memcpy(&amp;newnode,&amp;head,sizeof(struct node));//复制这新的状态
                swap(newnode.state[z], newnode.state[nz]);//把0移动到新的位置
                newnode.dis ++;
                if(memcmp(newnode.state,goal,sizeof(goal)) == 0)
                                                           //与目标状态对比
                    return newnode.dis;             //到达目标状态，返回距离，结束
                if(Cantor(newnode.state, 9))         //用康托展开判重
                    q.push(newnode);                   //把新的状态放进队列
             }
        }
    }
    return -1;            //没找到
}
int main(){
    for(int i = 0; i &lt; 9; i++)  cin &gt;&gt; start[i];       //初始状态
    for(int i = 0; i &lt; 9; i++)  cin &gt;&gt; goal[i];        //目标状态
    int num = bfs();
    if(num != -1)  cout &lt;&lt; num &lt;&lt; endl;
    else          cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl;
    return 0;
}
</code></pre>
<h2 id="三-a算法未探究">三、A*算法（未探究）</h2>
<p><img src="https://s3.bmp.ovh/imgs/2021/09/f7dd7d4ff6ad4be5.png" alt="" loading="lazy"><br>
在搜索过程中，用一个评估函数对当前情况进行评估，得到最好的状态，从这个状态继续搜索，直到目标。设x是当前所在的状态，f(x)是对x的评估函数，有：<br>
f(x) = g(x) + h(x)<br>
g(x)表示从初始态到x的实际代价，它不体现x和终点的关系。<br>
h(x)表示x到终点的最优路径的评估，它就是“启发式”信息，把h(x)称为启发函数。很显然，h(x)决定了A<em>算法的优劣。<br>
A</em>算法包含了BFS和贪心算法：<br>
（1）如果h(x) = 0，有f(x) = g(x)，就是普通的BFS算法；<br>
（2）如果g(x) = 0，有f(x) = h(x)，就是贪心算法，此时图中标注’*’的方块也会被访问到。</p>
<h2 id="四-双向广搜bfs的增强版未探究">四、双向广搜：BFS的增强版（未探究）</h2>
<h3 id="1介绍-3">1.介绍</h3>
<p>同时在起点和目标点向对方做BFS。<br>
双向广搜比只做一次BFS，搜索的空间减少很多，从而更有效率。<br>
双向广搜的应用场合是：知道起点和终点，并且正向和逆向都能进行搜索。</p>
<h3 id="2例题-2">2.例题</h3>
<p>双向广搜例题：hdu 1401<br>
有一个8x8的棋盘，上面有4颗棋子，棋子可以上下左右移动。给定一个初始状态，和一个目标状态，问能否在8步内到达。<br>
思路：从起点和终点分别开始，各自广搜4步，如果出现交点则说明可达。<br>
程序比较繁琐，有很多细节需要处理，但是难度不高。<br>
hdu 3567用双向广搜解决八数码问题。</p>
<h2 id="五-dfs">五、DFS</h2>
<h3 id="1介绍-4">1.介绍</h3>
<p>在hdu 1312题（BFS例题），有另外一种算法。<br>
（1）在初始位置，令num=1，标记这个位置已经走过；<br>
（2）左、上、右、下4个方向，按顺时针顺序选一个方向走一步；<br>
（3）在新的位置，num++，标记这个位置已经走过；<br>
（4）继续前进，如果无路可走，回退到上一步，换个方向再走；<br>
（5）继续以上过程，直到结束。<br>
在一个位置，只要有路，就一直走到最深处，直到无路可走，再退回一步，看在上一步的位置能不能换个方向继续往下走。这样就遍历了所有可能走到的位置。<br>
这个思路就是深度搜索。从初始状态出发，下一步可能有多种状态；选其中一个状态深入，到达新的状态；直到无法继续深入，就回退到前一步，转移到其它状态，然后再深入下去。最后，遍历完所有可以到达的状态，并得到最终的解。</p>
<h3 id="2dfs和bfs">2.DFS和BFS</h3>
<p>复杂度：DFS和BFS对大小为m<em>n的图，做一次遍历，复杂度是O(m</em>n)。<br>
应用场合。DFS用递归实现，程序比BFS更短，一般优先使用。<br>
不过，像迷宫这样的求最短路径问题，应该用BFS。</p>
<h3 id="3例题">3.例题</h3>
<p>hdu 1312题（BFS例题）</p>
<pre><code>//ECUST luoyongjun
#include&lt;bits/stdc++.h&gt;
using namespace std;
char room[23][23];
int dir[4][2] = {
    {-1,0},  //向左。左上角坐标是(0, 0)
    {0,-1},  //向上
    {1,0},   //向右
    {0,1}    //向下
};
int Wx, Hy, num;                 //Wx行，Hy列。用num统计可走的位置有多少
#define CHECK(x, y) (x&lt;Wx &amp;&amp; x&gt;=0 &amp;&amp; y &gt;=0 &amp;&amp; y&lt;Hy) //是否在room里
struct node {int x,y;};
void DFS(int dx, int dy){
    room[dx][dy] = '#';                 //标记这个位置，表示已经走过
      // cout&lt;&lt;&quot;walk:&quot;&lt;&lt;dx&lt;&lt;dy&lt;&lt;endl; //在此处打印走过的位置，验证是否符合
    num++;
    for(int i = 0; i &lt; 4; i++) {      //左、上、右、下，4个方向顺时针深搜
        int newx = dx + dir[i][0];
        int newy = dy + dir[i][1];
        if(CHECK(newx, newy) &amp;&amp; room[newx][newy] == '.'){
             DFS(newx, newy);
             // cout&lt;&lt;&quot;    back:&quot;&lt;&lt;dx&lt;&lt;dy&lt;&lt;endl;
 //在此处打印回退的点的坐标，观察深搜到底后，回退的情况
//例如到达最后的15这个位置后，会一直退到起点
//即打印出14-11-10-9-8-7-6-5-4-3-2-1。这也是递归程序返回的过程
        }
    }
}

int main(){
    int x, y, dx, dy;
    while (cin &gt;&gt; Wx &gt;&gt; Hy) {   	          //Wx行，Hy列
        if (Wx==0 &amp;&amp; Hy==0)   			 //结束
            break;
        for (y = 0; y &lt; Hy; y++) {         //有Hy列
            for (x = 0; x &lt; Wx; x++) { 	 //一次读入一行
                cin &gt;&gt; room[x][y];
                if(room[x][y] == '@') {     //读入起点
                    dx = x;
                    dy = y;
                }
            }
        }
        num = 0;
        DFS(dx, dy);
        cout &lt;&lt; num &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h2 id="六-dfs回溯与剪枝">六、DFS：回溯与剪枝</h2>
<p>递归列举出所有的路径，可能会因为数量太大而超时。<br>
很多子结点是不符合条件的，可以在递归的时候，“看到不对头就撤退”，中途停止扩展并返回。<br>
这就是回溯，回溯中用于减少子结点扩展的函数是剪枝函数。</p>
<h3 id="1回溯的经典问题八皇后">1.回溯的经典问题：八皇后</h3>
<p>•	在棋盘上放置8个皇后，使它们不同行、不同列、不同对角线。问有多少种合法的情况。<br>
•	N皇后问题是八皇后问题的扩展。<br>
<img src="https://s3.bmp.ovh/imgs/2021/09/a71c4c902171fcd6.png" alt="" loading="lazy"><br>
N皇后是什么难度的问题？<br>
<img src="https://eric-tom.github.io/post-images/1630677085625.png" alt="" loading="lazy"></p>
<h3 id="2代码-2">2.代码</h3>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n, tot = 0;
int col[12] = {0};
bool check(int c, int r) {              //检查是否和已经放好的皇后冲突
    for(int i = 0; i &lt; r; i++)
        if(col[i] == c || (abs(col[i]-c) == abs(i -r))) //取绝对值
            return false;
    return true;
}
void  DFS(int r) {                   //一行一行地放皇后，这一次是第r行
    if(r == n) {             //所有皇后都放好了，递归返回
       tot++;                  //统计合法的棋局个数
       return;
    }
    for(int c = 0; c &lt; n; c++)      //在每一列放皇后
        if(check(c, r)){              //检查是否合法
            col[r] = c;                //在第r行的c列放皇后
            DFS(r+1);                   //继续放下一行皇后
        }
}
int main() {
    int ans[12]={0};
    for(n = 0; n &lt;= 10; n++){      //算出所有n皇后的答案。先打表不然会超时
        memset(col,0,sizeof(col)); //清空，准备计算下一个N皇后问题
        tot = 0;
        DFS(0);
        ans[n] = tot;                //打表
    }
    while(cin &gt;&gt; n) {
        if(n==0)
           return 0;
        cout &lt;&lt; ans[n] &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h2 id="七-迭代加深搜索iddfs未探究">七、迭代加深搜索IDDFS（未探究）</h2>
<h3 id="1介绍-5">1.介绍</h3>
<p>•	有些搜索树很特别：不仅很深，而且很宽；<br>
•	深度可能到无穷，宽度也可能极广。<br>
•	如果直接用DFS，会陷入递归无法返回；<br>
•	如果直接用BFS，队列空间会爆炸。</p>
<h3 id="2例题埃及分数">2.例题：埃及分数</h3>
<p>http://codevs.cn/problem/1288/<br>
•	在古埃及，人们使用单位分数的和（形如1/a，a是自然数）表示一切有理数。如：2/3=1/2+1/6，但不允许2/3=1/3+1/3，因为加数中有相同的。对于一个分数a/b，表示方法有很多种，但是哪种最好呢？首先，加数少的比加数多的好，其次，加数个数相同的，最小的分数越大越好。如：<br>
19/45=1/3 + 1/12 + 1/180，<br>
19/45=1/3 + 1/15 + 1/45<br>
19/45=1/3 + 1/18 + 1/30,<br>
19/45=1/4 + 1/6 + 1/180<br>
19/45=1/5 + 1/6 + 1/18<br>
•	最后一种最好，因为1/18比1/180、1/45、1/30、1/180都大。<br>
•	给出a, b (0 &lt; a &lt; b &lt; 1000)，编程计算最好的表达方式。<br>
解题思路：<br>
（1）DFS到第1层，只包括一个分数，如果满足要求就退出；<br>
（2）DFS前2层，是2个分数的和，例如1/2 + 1/3、1/2 + 1/4、1/2 + 1/5、…、1/3 + 1/4、…等等，找到合适的答案就退出；<br>
（3）DFS前3层…</p>
<h2 id="八-ida">八、IDA*</h2>
<h3 id="1介绍-6">1.介绍</h3>
<p>•	IDA*：A*算法思想在IDDFS中的应用。<br>
•	IDDFS仍然是一种“盲目”的搜索方法，只是把搜索范围约束到了可行的空间内。如果在进行IDDFS的时候，能预测出当前DFS的状态，不再继续深入下去，那么就可以直接返回，不再继续，从而提高了效率。<br>
•	这个预测就是在IDDFS中增加一个估价函数。在某个状态，经过函数计算，发现后续搜索无解，就返回。简单地说，就是IDDFS的过程中，利用估价函数进行剪枝操作。</p>
<h3 id="2例题poj3134">2.例题：poj3134</h3>
<p>•	给定数x和n，求xn，只能用乘法和除法，算过的结果可以被利用。问最少算多少次就够了。n&lt;=1000。<br>
•	分析：每一步搜索，用前一步得出的值和之前产生的所有值进行加、减运算得到新的值，判断这个值是否等于n。<br>
•	麻烦在于，每一步搜索，新值的数量增长极快。如果直接用DFS，深度可能有1000，可能会溢出；如果用BFS，也可能超出队列范围。<br>
•	这一题用IDDFS非常合适，再用估价函数进行剪枝，可以高效地完成计算。<br>
•	（1）IDDFS：指定递归深度，每一次做DFS时不超过这个深度；<br>
•	（2）估价函数：如果当前的值用最快的方式（连续乘2，倍增）都不能到达n，停止用这个值继续DFS。<br>
•	算法分析：<br>
<a href="https://imgtu.com/i/hcmReS"><img src="https://z3.ax1x.com/2021/09/03/hcmReS.png" alt="hcmReS.png" loading="lazy"></a><br>
•	思路分析：这道题说是乘除法，但是因为底数给的是x，所以我们需要算的只有指数部分，所以就相当于只能用加减法。问题就变成了：从1到n，只能用加减法，经过多少次运算可以得到。<br>
若使用dfs，就不知道要搜索多少层。而若使用bfs，因为每一步都要使用前一步的数据，所以数据增加的很快，队列可能会爆掉。因此，使用加深迭代搜索（限制深度地进行搜索）是比较合适的。<br>
另外，这里我们可以用一个估值函数进行剪枝，以提高效率。这里的估值函数是：假设从现在到现在制定的最大深度位置，每步都以最快的速度增长（每次都是*2就是增长最快）的之后仍然小于n，则这个情况可以剪枝掉。<br>
•	代码：</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int val[1010];                           //存一个搜索路径上每一步的计算结果
int pos, n;
bool ida(int now, int depth){
    if(now &gt; depth)  return false;     //IDDFS：大于当前设定的DFS深度，退出
    if(val[pos] &lt;&lt; (depth - now) &lt; n)
return false;                //估价函数：用最快的倍增，都不能到达n，退出
    if(val[pos] == n)  return true;    //当前结果等于n，搜索结束
    pos ++ ;
    for(int i = 0 ; i &lt; pos ; i ++) {
        val[pos] = val[pos-1] + val[i]; //上一个数与前面所有的数相加
        if(ida(now + 1, depth))   return true;
        val[pos] = abs(val[pos-1] - val[i]);//上一个数与前面所有的数相减
        if(ida(now + 1, depth))   return true;
    }
    pos -- ;
    return false;
}
int main(){
    int t;
    while(cin&gt;&gt;n &amp;&amp; n){
        int depth;
        for(depth = 0 ; ; depth ++){ //每次只DFS到深度depth
            val[pos = 0] = 1;          //初始值是1
            if(ida(0, depth)) break; //每次都从0层开始DFS到第depth层
        }
        cout &lt;&lt; depth &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h1 id="第四节-高级数据结构">第四节 高级数据结构</h1>
<p>##一、并查集<br>
•	并查集（Disjoint Set）：一种非常精巧而实用的数据结构。<br>
•	用于处理不相交集合的合并问题。<br>
•	经典应用：<br>
连通子图<br>
最小生成树Kruskal算法<br>
最近公共祖先<br>
例题<br>
例：hdu 1213 How Many Tables<br>
•	有n个人一起吃饭，有些人互相认识。认识的人想坐在一起，而不想跟陌生人坐。例如A认识B，B认识C，那么A、B、C会坐在一张桌子上。<br>
•	给出认识的人，问需要多少张桌子。<br>
并查集的操作<br>
•	初始化<br>
•	合并<br>
•	查找</p>
<pre><code>•	void init_set(){                       //初始化       
•	   for(int i = 1; i &lt;= maxn; i++)
•	        s[i] = i;
•	}
•	void union_set(int x, int y){    //合并
•	    x = find_set(x);
•	    y = find_set(y);
•	    if(x != y) s[x] = s[y];
•	}
•	int find_set(int x){                   //查找   （递归）
•	    return x==s[x]? x:find_set(s[x]);
•	}
</code></pre>
<p>有多少个集（帮派）？<br>
•	如果s[i] = i，这是一个根结点，是它所在的集的代表（帮主）；<br>
•	统计根结点的数量，就是集的数量。<br>
复杂度<br>
•	查找find_set()、合并union_set()的搜索深度是树的长度，复杂度都是O(n)。<br>
•	性能差。<br>
•	能优化吗？<br>
目标：优化之后，复杂度 &lt; O(logn)。<br>
合并的优化<br>
•	合并元素x和y时，先搜到它们的根结点；<br>
•	合并这两个根结点：把一个根结点的集改成另一个根结点。<br>
•	这两个根结点的高度不同，把高度较小的集合并到较大的集上，能减少树的高度。<br>
查询的优化：路径压缩<br>
•	查询程序find_set()：沿着搜索路径找到根结点，这条路径可能很长。<br>
•	优化：沿路径返回时，顺便把i所属的集改成根结点。下次再搜，复杂度是O(1)。<br>
路径压缩：非递归实现</p>
<pre><code>如果数据规模太大，用递归担心爆栈，可以这样写：
int find_set(int x){
    int r = x;
    while ( s[r] != r ) r=s[r]; //找到根结点
    int i = x, j;
    while(i != r){   
         j = s[i]; //用临时变量j记录
         s[i]= r ; //把路径上元素的集改为根结点
         i = j;
    }
    return r;
}

</code></pre>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1050;
int s[maxn];
int height[maxn];
void init_set(){
   for(int i = 1; i &lt;= maxn; i++){
        s[i] = i;
        height[i]=0;                     //树的高度
   }
}

int find_set(int x){
    if(x != s[x]) s[x] = find_set(s[x]);   //路径压缩
    return s[x];
}
void union_set(int x, int y){         //优化合并操作
    x = find_set(x);
    y = find_set(y);
    if (height[x] == height[y]) {
        height[x] = height[x] + 1;      //合并，树的高度加一
        s[y] = x;
    }
    else{                            //把矮树并到高树上，高的树的高度不变
        if (height[x] &lt; height[y])  s[x] = y;
        else   s[y] = x;
    }
}

int main (){
    int t, n, m, x, y;
    cin &gt;&gt; t;
    while(t--){
        cin &gt;&gt; n &gt;&gt; m;
        init_set();
        for(int i = 1; i &lt;= m; i++){
            cin &gt;&gt; x &gt;&gt; y;
            union_set(x, y);
        }
        int ans = 0;
        for(int i = 1; i &lt;= n; i++)   //统计有多少个集
            if(s[i] == i)
                ans++;
        cout &lt;&lt; ans &lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h2 id="二-二叉树">二、二叉树</h2>
<h2 id="三-线段树">三、线段树</h2>
<h2 id="四-树状数组">四、树状数组</h2>
<h1 id="第十节-其他知识">第十节 其他知识</h1>
<h2 id="一string-char-int-相互转换">一.string char int 相互转换</h2>
<pre><code>1.string--&gt;const char*--&gt;int
 例子：
string tmp=&quot;110&quot;;
int c=atoi(tmp.c_str())+1;
cout&lt;&lt;tmp&lt;&lt;endl;//110
cout&lt;&lt;c&lt;&lt;endl;//111
2.char&lt;--&gt;int(10以内)
//int类型转换为char类型
int num = 6;
char c = num + '0';
cout&lt;&lt;c&lt;&lt;endl;	
//char类型转换为int类型
char c1 = '4';
int num1 = c1 - '0';
cout&lt;&lt;num1&lt;&lt;endl;

3.string--&gt;char*
#include&lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
using namespace std;
int main(void)
{
    //data()方法 
    string str = &quot;hello&quot;;
    //使用char * p=(char*)str.data()效果相同
    const char* p1 = str.data();
    cout&lt;&lt;p1&lt;&lt;endl;
    //c_str()方法
    str = &quot;world&quot; ;
    //使用char * p=(char*)str.c_str()效果相同
    const char *p2 = str.c_str();
    cout&lt;&lt;p2&lt;&lt;endl;
    //copy()方法
    str=&quot;world&quot;;
    char p3[50];
    //s.copy(cstr, n, pos)       从字符数组cstr的pos位置开始，复制n个字符到字符串s中
    str.copy(p3, 5, 0);         
    *(p3+5)= '\0';                 //添加结束符
    cout&lt;&lt;p3&lt;&lt;endl;
}

4.char *--&gt;string
string s;
char *p = &quot;helloworld&quot;;
s = p;

5.string--&gt;char[]
string pp = &quot;helloworld&quot;;
char p[20];
int i;
for( i=0;i&lt;pp.length();i++)
    p[i] = pp[i];
p[i] = '\0';                  //添加结束符

6.char[]--&gt;string
string s;
char p[20] = &quot;helloworld&quot;;
s = p;

7.char[]--&gt;char*
char pp[20] = &quot;helloworld&quot;;
char* p = pp;

8.char*--&gt;char[]
#include&lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
using namespace std;
int main(void)
{	
    //利用&lt;string.h&gt;库的strcpy()方法     
    char arr1[20];
    char* tmp1 = &quot;helloworld&quot;;
    strcpy(arr1, tmp1);
    cout&lt;&lt;arr1&lt;&lt;endl;
    //循环遍历
    char arr2[20];
    char* tmp2 = &quot;helloworld&quot;;
    int i = 0;
    while (*tmp2 != '\0')
            arr2[i++] = *tmp2++;
    arr2[i] = '\0';             //添加结束符
    cout&lt;&lt;arr2&lt;&lt;endl;	
}

9.int--&gt;string
#include&lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
using namespace std;
int main(void)
{
	int a = 7;
	float b = 3.14;
	double c = 1.415649363;
	//利用string库函数中函数to_string 
	string a_str = to_string(a);
	string b_str = to_string(b);
	string c_str = to_string(c);
	cout &lt;&lt; &quot;a&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;b&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;c&quot; &lt;&lt; endl;
}

10.string--&gt;int
#include&lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
using namespace std;
int main(void)
{
	string num_str = &quot;2142&quot;;
	//利用string库中的stoi函数 
	int num_int = stoi(num_str);
	cout&lt;&lt;num_int&lt;&lt;endl;
	//利用标准库中的atoi函数
	string s = &quot;51426&quot;;
	int value = atoi(s.c_str());
	cout &lt;&lt; value &lt;&lt; endl;
}
char* 和 char[]区别的一些理解 https://blog.csdn.net/u012611878/article/details/7829103

11.
string 对象与字符数组互操作
下面这个程序演示了字符数组与 string 对象的输入与输出：
#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;
int main(int argc, char* argv[])
{
    string s;
    char ss[100];
    //输入字符串到字符数组中
    scanf(&quot;%s&quot;,&amp;ss);
    //字符数组赋值线字符串对象
    s=ss;
    //用 printf 输出字符串对象，要采用 c_str()方法
    printf(s.c_str());
    //换行
    cout&lt;&lt;endl;
    //用 printf 输出字符数组
    printf(&quot;%s&quot;,ss);
    //换行
    cout&lt;&lt;endl;
    //用 cout 输出字符串对象
    cout&lt;&lt;s&lt;&lt;endl;
    //用 cout 输出字符数组
    cout&lt;&lt;ss&lt;&lt;endl;
    return 0;
}
输出结果（从键盘输入“abc123”字符串后回车）：
abc123
abc123
abc123
abc123
abc123

12.string 对象与 sscanf 函数
在 C 语言中，sscanf 函数很管用，它可以把一个字符串按你需要的方式分离出子串，
甚至是数字。下面这个程序演示了 sscanf 函数的具体用法：
#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;
int main(int argc, char* argv[])
{
    string s1,s2,s3;
    char sa[100],sb[100],sc[100];
    //将字符串分离成子串，分隔符为空格
    sscanf(&quot;abc 123 pc&quot;,&quot;%s %s %s&quot;,sa,sb,sc);
    s1=sa;
    s2=sb;
    s3=sc;
    cout&lt;&lt;s1&lt;&lt;&quot; &quot;&lt;&lt;s2&lt;&lt;&quot; &quot;&lt;&lt;s3&lt;&lt;endl;
    //将字符串分离成数字，分隔符为空格
    //当用到数字的时候，跟 scanf 一样，它要传指针地址
    int a,b,c;
    sscanf(&quot;1 2 3&quot;,&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c);
    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;
    //将字符串分离成数字，分隔符为“,”和“$”
    //当用到数字的时候，跟 scanf 一样，它要传指针地址
    int x,y,z;
    sscanf(&quot;4,5$6&quot;,&quot;%d,%d$%d&quot;,&amp;x,&amp;y,&amp;z);
    cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;endl;
    return 0;
}
运行结果：
36

abc 123 pc
1 2 3
4 5 6
1.  string 对象与数值相互转换
有时候，string 对象与数值之间需要相互转换，下面这个例子详细说明了如何完成这
项工作：
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
using namespace std;
//C++方法：将数值转换为 string
string convertToString(double x)
{
ostringstream o;
if (o &lt;&lt; x)
return o.str();
return &quot;conversion error&quot;;//if error
}
//C++方法：将 string 转换为数值
double convertFromString(const string &amp;s)
{
istringstream i(s);
double x;
if (i &gt;&gt; x)
return x;
return 0.0;//if error
}
int main(int argc, char* argv[])
{
//将数值转换为 string 的第一种方法：C 方法
char b[10];
string a;
sprintf(b,&quot;%d&quot;,1975);
a=b;
cout&lt;&lt;a&lt;&lt;endl;
//将数值转换为 string 的第二种方法：C++方法
string cc=convertToString(1976);
cout&lt;&lt;cc&lt;&lt;endl;
//将 string 转换为数值的方法：C++方法
string dd=&quot;2006&quot;;
int p=convertFromString(dd)+2;
cout&lt;&lt;p&lt;&lt;endl;
return 0;
}


总结
#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
	/*vector&lt;int&gt; m;
	vector&lt;int&gt; n;
	m.push_back(1);
	m.push_back(3);
	n.push_back(2);
	n.push_back(4);
	map&lt;int,string&gt; mq;
    mq.insert(pair&lt;int,string&gt;(3,&quot;qwe&quot;));
    mq.insert(pair&lt;int,string&gt;(4,&quot;qwddsa&quot;));
    mq.insert(pair&lt;int,string&gt;(1,&quot;123sd&quot;));
    cout&lt;&lt;mq[1]&lt;&lt;endl;
    //定义 map 对象，当前没有任何元素
    map&lt;int,char&gt; m;
    //插入元素，按键值的由小到大放入黑白树中
    m[25]='m';
    m[28]='k';
    m[10]='x';
    m[30]='a';
    //反向遍历元素
    map&lt;int,char&gt;::reverse_iterator rit;
    for(rit=m.rbegin();rit!=m.rend();rit++)
    {
    //输出键值与映照数据
    cout&lt;&lt;(*rit).first&lt;&lt;&quot; : &quot;&lt;&lt;(*rit).second&lt;&lt;endl;
    }*/
    //cout&lt;&lt;string(3,'c')&lt;&lt;endl;
    int a = 7;
    string a2;
    char *a3;
    string b=&quot;123&quot;;
    int b2;
    char *b3;
    char*p=&quot;567&quot;;
    string p2;
    int p3;
    char q[]=&quot;789&quot;;
    cout&lt;&lt;&quot;1.int-&gt;string&quot;&lt;&lt;endl;
    //利用string库函数中函数to_string
    a2 = to_string(a);
    cout&lt;&lt;a2&lt;&lt;endl;
    cout&lt;&lt;&quot;2.string-&gt;int&quot;&lt;&lt;endl;
	//利用string库中的stoi函数
	b2 = stoi(b);
	cout&lt;&lt;b2&lt;&lt;endl;
	//利用标准库中的atoi函数
	b2 = atoi(b.c_str());
	cout&lt;&lt;b2&lt;&lt;endl;
    cout&lt;&lt;&quot;3.int-&gt;char&quot;&lt;&lt;endl;
    //C++流对象转换
    int aa = 123;
    ostringstream ss;
    ss &lt;&lt; aa;
    cout &lt;&lt;ss.str() &lt;&lt; endl;
    //sprintf()数字转化为字符串
    sprintf(a3, &quot;%d&quot;,a);
    cout&lt;&lt;a3&lt;&lt;endl;
    cout&lt;&lt;&quot;4.char-&gt;int&quot;&lt;&lt;endl;
	p3 = atoi(p);
	cout&lt;&lt;p3&lt;&lt;endl;
	//sscanf(m,&quot;%d&quot;,&amp;x);字符串转化为数字
	/*const char* p4=&quot;101&quot;;
	sscanf(p4,&quot;%s&quot;,&amp;p3);
	cout&lt;&lt;p3&lt;&lt;endl;*/
    cout&lt;&lt;&quot;5.string-&gt;char&quot;&lt;&lt;endl;
    //data()方法

    //c_str()方法
    //使用char * p=(char*)str.c_str()效果相同
    const char *b4 = b.c_str();
    cout&lt;&lt;b4&lt;&lt;endl;
    cout&lt;&lt;&quot;6.char-&gt;string&quot;&lt;&lt;endl;
    string s11;
    char *p11 =&quot;helloworld&quot;;
    s11 = p11;
    cout&lt;&lt;s11&lt;&lt;endl;
}

</code></pre>
<h2 id="二-常用头文件">二、常用头文件</h2>
<ol>
<li>万能头文件<br>
#include&lt;bits/stdc++.h&gt;包含了目前c++所包含的所有头文件</li>
<li>#include<cstdlib></li>
</ol>
<ul>
<li>rand()重复运行不会变化，所以加入srand(int x)<br>
要在每次运行程序时获得不同的随机数字流，则必须为随机数生成器提供一个种子以开始。在 C++ 中，这是通过调用 srand 函数完成的。<br>
在 rand 被调用之前，srand 函数要先被调用，并且 srand 在整个程序中仅被调用一次<br>
如果你要产生0~99这100个整数中的一个随机整数，可以表达为：int num = rand() % 100;<br>
如果要产生1~100，则是这样：int num = rand() % 100 + 1;<br>
#<ctime> srand(time(0));srand((int)time(0));<br>
例如0-2</li>
</ul>
<pre><code>    srand(time(0));
    for(int i=0;i&lt;10;i++)
    {
        int q=rand()%3;
        cout&lt;&lt;q&lt;&lt;endl;
    }
</code></pre>
<ol start="3">
<li>#include<iomanip></li>
</ol>
<ul>
<li>setw(n)<br>
宽度设置用于输人时，只对字符串有效,输出时指最小输出宽度。<br>
与宽度设置有关的操作符是: setw(int n)<br>
等价函数调用为:io.width(n)<br>
其中,n是一个表示宽度的表达式。如果用于字符串输人，实际输人的字符串的最大长<br>
度为n-1,也就是宽度n包含字符串结束符在内。函数width返回此前设置的宽度。<br>
当实际数据宽度小于指定宽度时，多余位置用填充字符(通常是空格)填满:当实际数据<br>
宽度大于设置宽度时，仍按实际宽度输出。初始宽度值为0,表示按实际宽度输出。<br>
注意:宽度设置的效果只对次输 人或输出有效，在完成一 个数据的输 人或输 出后,宽<br>
度设置自动恢复为0(表示按数据实际宽度输入输出)。宽度设置是所有格式设置中唯的<br>
一次有效的设置。</li>
<li>setprecision(int n)<br>
输入输出精度是针对浮点数的，如果采用浮点数格式，精度含义是有效位数；如果采用定点格式或指数形式为小数位数。默认精度为6，<br>
设置为0意味回到默认，设置精度一直有效。</li>
</ul>
<pre><code>const double value = 12.3456789;
cout &lt;&lt; setprecision(4) &lt;&lt; value &lt;&lt; endl; // 改成4精度，所以输出为12.35
cout &lt;&lt; setprecision(8) &lt;&lt; value &lt;&lt; endl; // 改成8精度，所以输出为12.345679
cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; value &lt;&lt; endl; // 加了fixed意味着是固定点方式显示，所以这里的精度指的是小数位，输出为12.3457
cout &lt;&lt; value &lt;&lt; endl; // fixed和setprecision的作用还在，依然显示12.3457
cout.unsetf( ios::fixed ); // 去掉了fixed，所以精度恢复成整个数值的有效位数，显示12.35
cout &lt;&lt; value &lt;&lt; endl;
cout.precision( 6 ); // 恢复成原来的样子，输出为12.3457
cout &lt;&lt; value &lt;&lt; endl;
</code></pre>
<ul>
<li>setfill(char c)填充字符  ，初始为空格</li>
</ul>
<ol start="4">
<li>#include <cstring></li>
</ol>
<ul>
<li>sprintf(s, &quot;%d&quot;,x);数字转化为字符串 <code>char s[10];int x</code></li>
<li>sscanf(m,&quot;%d&quot;,&amp;x);<br>
sscanf(m,&quot;%s&quot;,&amp;x);字符串转化为数字   数字要传递指正地址所以要用到&amp;,  &amp;x;可以按照你需要的方式分离出子串,</li>
</ul>
<pre><code>char sa[10],sb[10],sc[10];
sscanf(&quot;abc 123 pc&quot;,&quot;%s %s %s&quot;,sa,sb,sc);
</code></pre>
<ul>
<li>strrev(m) 字符串反转</li>
<li>strlen()返回字符串长度无'\0'</li>
<li>strcpy()复制字符串</li>
<li>strncpy()多了个复制个数</li>
<li>char *strncpy( char *to, const char *from, size_t count );</li>
<li>strcat()连接两个字符串;</li>
<li>char *strncat( char *str1, const char *str2, size_t count );</li>
<li>int strcmp( const char *str1, const char *str2 );比较字符串</li>
<li>int strncmp( const char *str1, const char *str2, size_t count );<br>
&lt;0 str1 is less than str2<br>
=0 str1 is equal to str2</li>
</ul>
<blockquote>
<p>0 str1 is greater than str2</p>
</blockquote>
<ul>
<li>strchr<br>
函数原型：extern char *strchr(char *str,char character)<br>
参数说明：str为一个字符串的指针，character为一个待查找字符。<br>
所在库名：#include &lt;string.h&gt;<br>
函数功能：从字符串str中寻找字符character第一次出现的位置。<br>
返回说明：返回指向第一次出现字符character位置的指针，如果没找到则返回NULL。<br>
其它说明：还有一种格式char *strchr( const char *string, int c )，这里字符串是以int型给出的（int character='k' ;）</li>
<li>memset(<br>
void *memset(void *s, int v, size_t n);<br>
复制字符 v（一个无符号字符）到参数 s 所指向的字符串的前 n 个字符。<br>
这里s可以是数组名，也可以是指向某一内在空间的指针；<br>
v为要填充的值；<br>
n为要填充的字节数；<br>
(在memset使用时要千万小心，在给char以外的数组赋值时，只能初始化为0或者-1。比如int s[3][3];<br>
只能memset(a, 0, 36);或者memset(a, -1, 36)😉<br>
例，</li>
</ul>
<pre><code>char buffer[] = &quot;This is a test of the memset function&quot;;
cout &lt;&lt; buffer &lt;&lt; endl;
memset(buffer, '*', 4);
\\或者memset(buffer, '*', sizeof(buffer)-1);字符串会多一个'\0'
cout &lt;&lt; buffer &lt;&lt; endl;
</code></pre>
<ul>
<li>memcpy<br>
#include &lt;string.h&gt;<br>
void *memcpy( void *to, const void *from, size_t count );<br>
功能：函数从from中复制count 个字符到to中，并返回to指针。 如果to 和 from 重叠，则函数行为不确定。</li>
<li>memcmp<br>
#include &lt;string.h&gt;<br>
int memcmp( const void *buffer1, const void *buffer2, size_t count );<br>
功能：函数比较buffer1 和 buffer2的前count 个字符。返回值如下:<br>
Value                解释<br>
less than 0        buffer1 is less than buffer2<br>
equal to 0         buffer1 is equal to buffer2<br>
greater than 0   buffer1 is greater than buffer2</li>
</ul>
<ol start="5">
<li>#include<algorithm></li>
</ol>
<ul>
<li>reverse函数功能是逆序（或反转），多用于字符串、数组、容器。头文件是#include <algorithm><br>
reverse函数用于反转在[first,last)范围内的顺序（包括first指向的元素，不包括last指向的元素），reverse函数无返回值<br>
eg.<br>
string str=&quot;hello world , hi&quot;;<br>
reverse(str.begin(),str.end());//str结果为 ih , dlrow olleh<br>
vector<int> v = {5,4,3,2,1};<br>
reverse(v.begin(),v.end());//容器v的值变为1,2,3,4,5</li>
<li>sort(begin,end,cmp),cmp参数可以没有,如果没有默认非降序排序。cmp需要自己设计<br>
若设计为非升序排序，则cmp函数的编写：</li>
</ul>
<pre><code>bool cmp（int a,int b）
{
　　return a&gt;b;
}
</code></pre>
<ol start="6">
<li>其他</li>
</ol>
<ul>
<li>getchar()<br>
三种用法：<br>
1、从缓冲区bai读du走一个字符，相当于清除缓冲区 <br>
2、前zhi面的scanf()在读取输入时会在缓冲区中留下一个字符dao'\n'（输入完s[i]的值后按回车键所致），所以如果不在此加一个getchar()把这个回车符取走的话，gets(）就不会等待从键盘键入字符，而是会直接取走这个“无用的”回车符，从而导致读取有误 <br>
3、getchar()是在输入缓冲区顺序读入一个字符(包括空格、回车和Tab) <br>
错在getchar() 是从键盘读取一个字符放入缓冲区，然后在取出来，你在输入某个数或者字符后敲回车其实缓冲区也接受了你的回车了。<br>
可以这么修改：</li>
</ul>
<pre><code>char ch;
int key;
printf(&quot;please input key&quot;);
scanf(&quot;%d&quot;,&amp;key);
fflush(stdin);
printf(&quot;please input ming wen\n&quot;);
ch=getchar();
fflush(stdin);
while(ch!='\n')
{
    putchar(ch+key);
    printf(&quot;\n&quot;);
    ch=getchar();
    fflush(stdin);
}
</code></pre>
<p>加上fflush(stdin);来清空缓冲区<br>
想要程序结束，直接敲回车就可以了</p>
<ol start="7">
<li>#include <numeric></li>
</ol>
<ul>
<li>accumulate函数<br>
在头文件 #include <numeric> 里（但是我用的时候在PAT里面不写头文件似乎也没关系……）<br>
主要是用来累加容器里面的值，比如int、string之类，可以少写一个for循环<br>
比如直接统计 vector<int> v 里面所有元素的和：（第三个参数的0表示sum的初始值为0）<br>
int sum = accumulate(v.begin(), v.end(), 0);<br>
比如直接将 vector<string> v 里面所有元素一个个累加到string str中：（第三个元素表示str的初始值为空字符串）<br>
string str = accumulate(v.begin(), v.end(), &quot;&quot;);</li>
</ul>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://eric-tom.github.io/post/shu-ju-jie-gou-yu-suan-fa-c/">
                  <h3 class="post-title">
                    Markdown基本语法
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
